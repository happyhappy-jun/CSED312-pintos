# Project 2: User Programs

## Preliminaries

Team Number: 20

윤병준(20190766)

김치헌(20190806)

## Table of Contents

# Analysis of current implementation

## Process execution procedure
핀토스 부팅시의 불리는 엔트리포인트 `init.c`의 `main()` 을 보면 User Program 을 위해 initialize하는
함수들을 볼 수 있다. `tss_init(), gdt_init()` 등의 세그먼트 초기화 과정이 첫번째고, `exeception_init(),
syscall_init()` 등의 User mode 프로세스에서의 발생할 수 있는 internal interrupt 와 handler,
syscall 등을 초기화한다. Segment란 x86 아키텍쳐에서 메모리를 조각내어 (segment) 하여 관리하고, 각 segment 에 대한 정보가
GDT(Global Descriptor Table) 에 저장되어 있다. GDT에서는 kernal code, kernal data, user code, user data,
tss 의 세그먼트에 대한 디스크립터가 저장되어있다. tss 는 Task State Segment 로서, 현재 실행중인 task switching 하는데 사용한다.
이 세그먼트에서는 유저 모드에서 인터럽트가 발생했을 때, 현재 TSS의 `ss0, esp0` 에 저장하고, ring0 (kernal mode) 의
스택 정보를 불러와 인터럽트를 처리한다.

```c
void tss_init(void) {
  // alloc tss 
  tss->ss0 = SEL_KDSEG;
  tss->bitmap = 0xdfff;
  tss_update();
}

void tss_update(void) {
  ASSERT(tss != NULL);
  tss->esp0 = (uint8_t *) thread_current() + PGSIZE;
}
```

GDT의 세그먼트 디스크립터에는 base, limit, class, type, dpl 등의 정보가 저장되어있다.

![GDT](./asset/p2_seg_desc.png)

위 그림에서 GDT 의 구조를 알 수 있다. 이 구조중에서 중요한 부분은 DPL 인데, DPL 은 Descriptor Privilege Level 의 약자로서
해당 세그먼트의 권한 레벨을 나타낸다. 0 가 kernal previleged level 이고, 3 이 user previleged level 이다. 이 DPL
값에 따라서, 현재 실행중인 프로세스가 해당 세그먼트에 접근할 수 있는지 관리하게 된다.

그 다음 단계에서는 인터럽트의 초기화를 해준다. `intr_init()`에서 IDT(Interrupt Descriptor Table) 을 초기화하고,
IDT 레지스터 `lidt` 를 통해 IDT 를 로드한다. IDT 는 인터럽트가 발생했을 때, 해당 인터럽트를 처리할 핸들러의 주소를 저장하고 있다.

여기서 잠시 짚고 넘어가야하는 것은 시스템 내에는 gate 라 불리는 특수한 디스크립터도 존재한다 (e.g. call gate, interrupt gate,
trap gate, task gate). 이 게이트는 application program 이나 procedure 와 다른 권한 (privilege) 레벨의
code를 호출할 때의 protected gateway 로써 제공하는 기능이다. 예를 들다면 call gate 에 대한 CALL 은
같거나 더 낮읒 권한 레벨의 code 를 호출 할 수 있게 해준다. Calling procedure 가 call gate 의 셀렉터를 제공하면,
프로세서가 call gate 의 디스크립터에서 권한 레벨과 타겟 코드 세그먼트의 권한 레벨을 비교해 더 낮은 권한 레벨의 코드를 호출할 수 있게 해준다.
만약 이러한 접근이 허용되면 프로세서는 타겟 코드의 세그먼트 셀렉터를 획득해 해당 코드를 수행할 수 있게 된다.

IDT 는 이러한 기능을 지원하는 interrupt gate 들을 저장하고 있다. 인터럽트 핸들링은 커널 모드에서 수행되기 때문에,
유저 프로그램 수행시 발생한 인터럽트 핸들링은 커널 코드 세그먼트를 요구하고, 그 `intr_gate` 들이 IDT 에 저장된다. (그 외에도 
`exception.c` 의 `exception_init()` 에서 정의한 `trap_gate` 등도 추가로 포함되어있다.)
```c
void intr_init(void) {
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init();

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
    // interrupt gate 를 만들어서 idt 에 저장한다.
    idt[i] = make_intr_gate(intr_stubs[i], 0);

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand(sizeof idt - 1, idt);
  asm volatile("lidt %0"
               :
               : "m"(idtr_operand));
  }
  
static void
register_handler(uint8_t vec_no, int dpl, enum intr_level level,
                 intr_handler_func *handler, const char *name) {
  ASSERT(intr_handlers[vec_no] == NULL);
  if (level == INTR_ON)
    // exception_init 에서 추가하는 트랩 게이트 
    idt[vec_no] = make_trap_gate(intr_stubs[vec_no], dpl);
  else
    // external device 에서 `intr_register_ext` 로 추가하는 인터럽트 게이트
    idt[vec_no] = make_intr_gate(intr_stubs[vec_no], dpl);
  intr_handlers[vec_no] = handler;
  intr_names[vec_no] = name;
}
```

이렇게 프로그램이 실행될 환경을 셋업한 이후에 `run_actions(argv)` 를 호출해 프로그램을 시작하게 된다. 
`run_actions(argv)` 의 커맨드를 확인해 보면, `action` 에 `run` 들어오게 되면, 
`run_task()` -> `process_exeecute(task)` 을 순차적으로 불러 프로세스를 실행하게 된다. 

`process_execute(task)`는 `task` 의 이름으로 스레드를 생성하고, `start_process` 를 하게 된다. 
```c
tid_t process_execute(const char *file_name) {
  // ...
  /* Create a new thread to execute FILE_NAME. */
  tid = thread_create(file_name, PRI_DEFAULT, start_process, fn_copy);
  if (tid == TID_ERROR)
    palloc_free_page(fn_copy);
  return tid;
}
```

`start_process`는 인터럽트 프레임을 설정하고, `load` 를 통해 프로그램을 메모리에 로드하고, `intr_exit` 을 이용해
마치 인터럽트에서 복귀하는 것처럼 프로그램을 실행한다. 로드에서 인자로 받는 `eip`, `esp` 는 `load` 함수에서 executable
의 엔트리 포인트를 `eip` 로 설정하고, 스택 포인터를 `esp` 로 설정한다. 

```c
bool load(const char *file_name, void (**eip)(void), void **esp) {
  
  /* load executable */
  
  // `setup_stack 은 페이지를 할당하고 esp 의 위치를 PHYS_BASE 로 설정한다.
  /*
   * 
 	
   PHYS_BASE +----------------------------------+
             |            user stack            |
             |                 |                |
             |                 |                |
             |                 V                |
             |          grows downward          |
             |                                  |
             |                                  |
             |                                  |
             |                                  |
             |           grows upward           |
             |                 ^                |
             |                 |                |
             |                 |                |
             +----------------------------------+
             | uninitialized data segment (BSS) |
             +----------------------------------+
             |     initialized data segment     |
             +----------------------------------+
             |           code segment           |
  0x08048000 +----------------------------------+
             |                                  |
             |                                  |
             |                                  |
             |                                  |
             |                                  |
           0 +----------------------------------+

   */
  if (!setup_stack(esp))
    goto done;

  /* Start address to Elf32_Ehdr's entry point */
  *eip = (void (*)(void)) ehdr.e_entry;
  
  // return true if all success
}
```

인터럽트에서 복귀하는 것 처럼 프로그램을 실행한다는 의미는 OS 가 `start_process`를 인터럽트 프레임을 
초기화 했고, 실행파일을 로드를 완료한 상태에서, `esp`, `eip` 가 적절하게 설정되었다면, 아래의 
`intr_exit`을 통해 로드한 해당 프로그램으로 진입할 수 있다는 의미다. 

```asm
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
	popl %gs
	popl %fs
	popl %es
	popl %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members.
            
            esp is set by setup_stack  (*esp = PHYS_BASE;)
        */
           
	addl $12, %esp

        /* Return to caller. (eip set to (void (*)(void)) ehdr.e_entry;) */
	iret
.endfunc
```


## System call procedure

## File system

TODO:

- structure(file, inode), functions(need to implement system call) of the file system in pintos
- see source codes (“filesys/ file.c”, “filesys/ inode.c” “filesys/filesys.c”) and section 3.1.2 on
  the manual

# Requirements

## 1. User Process

### A. Argument Passing
```
Address       Name            Data          Type
0xbffffffc    argv[3][...]    bar\0         char[4]
0xbffffff8    argv[2][...]    foo\0         char[4]
0xbffffff5    argv[1][...]    -l\0          char[3]
0xbfffffed    argv[0][...]    /bin/ls\0     char[8]
0xbfffffec    word-align      0             uint8_t
0xbfffffe8    argv[4]         0             char *
0xbfffffe4    argv[3]         0xbffffffc    char *
0xbfffffe0    argv[2]         0xbffffff8    char *
0xbfffffdc    argv[1]         0xbffffff5    char *
0xbfffffd8    argv[0]         0xbfffffed    char *
0xbfffffd4    argv            0xbfffffd8    char **
0xbfffffd0    argc            4             int
0xbfffffcc    return address  0             void (*) ()
```
위 예시는 `/bin/ls -l foo bar`를 실행했을 때, argument passing 이 구현된 상태에서의 스택이다. 
`PYBY_BASE` 는 0xc0000000 에서 시작해서 적절하게 데이터를 저장할 수 있도록 한다.
`argv` 는 `argv[0]` 부터 `argv[argc-1]` 까지의 주소를 가지고 있고, `argv[argc]` 는 `NULL` 을 가리킨다.
`argv[0]` 은 프로그램의 이름을 가리키고, `argv[1]` 부터는 프로그램의 인자들을 가리킨다. 인자로 받은 스트링은
`strtok_r` 함수로 공백으로 분리해서, 스택에 순서대로 push 해야한다. 위 케이스에서 stack pointer 는 `0xbfffffcc` 
로 초기화 되어야한다. 

#### Data Structure
```c
struct arg {
  int argc;
  char **argv;
};
```
인자들을 별개로 들고 다니기 여럽기 때문에, 새로운 `struct` 를 정의해 파싱한 인자들을 저장하도록 한다. 

#### Implementation
아래와 같은 로직으로 인자가 스택에 들어가야하는 순서를 요구 스펙 대로 스택에 푸쉬한다. 그 후 바이너리 로드시, setup 이 완료된 esp
에 인자들을 추가로 push 하면 된다. 
```diff
diff --git a/src/userprog/process.c b/src/userprog/process.c
--- a/src/userprog/process.c	(revision a4c2c916a136b1748a435d71d0add5afcb2ad1e8)
+++ b/src/userprog/process.c	(date 1697190591459)
@@ -112,6 +112,17 @@
   }
 }
 
+void push_arg_stack(char **argv, int argc, void **esp) {
+  // push arguments in reverse order
+  // align memory in multiple of word size for performance
+  // Add null pointer to argv[argc]
+  // push pointer to argument to argv[argc-1] to argv [0]
+  // push pointer to argv
+  // push argc
+  // push return address
+  // set esp to bottom of stack
+}
+
 /* Sets up the CPU for running user code in the current
    thread.
    This function is called on every context switch. */
@@ -197,7 +208,7 @@
    Stores the executable's entry point into *EIP
    and its initial stack pointer into *ESP.
    Returns true if successful, false otherwise. */
-bool load(const char *file_name, void (**eip)(void), void **esp) {
+bool load(struct arg *args, void (**eip)(void), void **esp) {
   struct thread *t = thread_current();
   struct Elf32_Ehdr ehdr;
   struct file *file = NULL;
@@ -285,6 +296,8 @@
   if (!setup_stack(esp))
     goto done;
 
+  push_arg_stack(arg, esp)
   /* Start address. */
   *eip = (void (*)(void)) ehdr.e_entry;
 

```



#### Algorithm

### B. Process Termination Messages

## 2. System Calls

### A. User Process Manipulation

### B. File Manipulation

## 3. Denying Writes to Executables

프로그램이 실행중일 때 바이너리 (executable) 이 수정된다면, 프로그램이 예상치 못한 동작을 할 수 있다. 따라서, 현재 실행중인
프로그램의 파일을 수정하지 못하게 protection 기능을 구현해야한다. 프로세스가 로드하기 위해 바이너리를 오픈 한 후에, 
파일에 대한 쓰기를 거부하도록 하고, 프로세스가 종료할 때, 다시 쓰기를 허용해주는 방식으로 하면, 실행중의 바이너리에 대한 쓰기를
막을 수 있다. 

### Data Structure

```diff
---
Index: src/threads/thread.h
===================================================================
diff --git a/src/threads/thread.h b/src/threads/thread.h
--- a/src/threads/thread.h	(revision 1361a982be7e58b65f837b05037cbff0c68526c2)
+++ b/src/threads/thread.h	(date 1697187720836)
@@ -108,6 +108,7 @@
 #ifdef USERPROG
   /* Owned by userprog/process.c. */
   uint32_t *pagedir; /* Page directory. */
+  struct file *file;
 #endif
 
   int original_priority;          /* Original priority of the thread */

```

이런식으로 `struct thread` 에 `file` 을 추가해 현재 실행중인 스레드가 어떤 파일에서 읽혔는지
load 시에 저장하고, exit 시에 레퍼런스 해서 allow 할 수 있도록 해준다. 


### Algorithm
프로세스 시작시에는 다음과 같이 `file_deny_write` 를 통해 파일에 대한 쓰기를 거부한다.
추가로 thread_current에 file의 레퍼런스를 저장에 종료시에 사용한다. 

```diff
bool load(const char *file_name, void (**eip)(void), void **esp) {
  // ...
  /* open executable */
  // ...
+  thread_current()->file = file;
+  file_deny_write(file);
   /* Read and verify executable header. */
   if (file_read(file, &ehdr, sizeof ehdr) != sizeof ehdr
       || memcmp(ehdr.e_ident, "\177ELF\1\1\1", 7)

```

프로세스 종료시에는 처음에 저장한 file 레퍼런스를 통해 `file_allow_write` 를 통해 쓰기를 허용한다.

```diff
void process_exit(void) {
+ if (thread_current()->file != NULL) {
+   file_allow_write(thread_current()->file);
+   file_close(thread_current()->file);
+ }
```