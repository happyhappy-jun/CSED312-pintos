# Project 2: User Programs

## Preliminaries

Team Number: 20

윤병준(20190766)

김치헌(20190806)

## Table of Contents

# Analysis of current implementation

## Process execution procedure

TODO: explain the procedure of process execution in the current pintos system
see source codes (“threads/init.c”, “userprog/process.c”)

핀토스 부팅시의 불리는 엔트리포인트 `init.c`의 `main()` 을 보면 User Program 을 위해 initialize하는
함수들을 볼 수 있다. `tss_init(), gdt_init()` 등의 세그먼트 초기화 과정이 첫번째고, `exeception_init(),
syscall_init()` 등의 User mode 프로세스에서의 발생할 수 있는 internal interrupt 와 handler,
syscall 등을 초기화한다. Segment란 x86 아키텍쳐에서 메모리를 조각내어 (segment) 하여 관리하고, 각 segment 에 대한 정보가
GDT(Global Descriptor Table) 에 저장되어 있다. GDT에서는 kernal code, kernal data, user code, user data,
tss 의 세그먼트에 대한 디스크립터가 저장되어있다. tss 는 Task State Segment 로서, 현재 실행중인 task switching 하는데 사용한다.
이 세그먼트에서는 유저 모드에서 인터럽트가 발생했을 때, 현재 TSS의 `ss0, esp0` 에 저장하고, ring0 (kernal mode) 의
스택 정보를 불러와 인터럽트를 처리한다.

```c
void tss_init(void) {
  // alloc tss 
  tss->ss0 = SEL_KDSEG;
  tss->bitmap = 0xdfff;
  tss_update();
}

void tss_update(void) {
  ASSERT(tss != NULL);
  tss->esp0 = (uint8_t *) thread_current() + PGSIZE;
}
```

GDT의 세그먼트 디스크립터에는 base, limit, class, type, dpl 등의 정보가 저장되어있다.

![GDT](./asset/p2_seg_desc.png)

위 그림에서 GDT 의 구조를 알 수 있다. 이 구조중에서 중요한 부분은 DPL 인데, DPL 은 Descriptor Privilege Level 의 약자로서
해당 세그먼트의 권한 레벨을 나타낸다. 0 가 kernal previleged level 이고, 3 이 user previleged level 이다. 이 DPL
값에 따라서, 현재 실행중인 프로세스가 해당 세그먼트에 접근할 수 있는지 관리하게 된다.

그 다음 단계에서는 인터럽트의 초기화를 해준다. `intr_init()`에서 IDT(Interrupt Descriptor Table) 을 초기화하고,
IDT 레지스터 `lidt` 를 통해 IDT 를 로드한다. IDT 는 인터럽트가 발생했을 때, 해당 인터럽트를 처리할 핸들러의 주소를 저장하고 있다.

여기서 잠시 짚고 넘어가야하는 것은 시스템 내에는 gate 라 불리는 특수한 디스크립터도 존재한다 (e.g. call gate, interrupt gate,
trap gate, task gate). 이 게이트는 application program 이나 procedure 와 다른 권한 (privilege) 레벨의
code를 호출할 때의 protected gateway 로써 제공하는 기능이다. 예를 들다면 call gate 에 대한 CALL 은
같거나 더 낮읒 권한 레벨의 code 를 호출 할 수 있게 해준다. Calling procedure 가 call gate 의 셀렉터를 제공하면,
프로세서가 call gate 의 디스크립터에서 권한 레벨과 타겟 코드 세그먼트의 권한 레벨을 비교해 더 낮은 권한 레벨의 코드를 호출할 수 있게 해준다.
만약 이러한 접근이 허용되면 프로세서는 타겟 코드의 세그먼트 셀렉터를 획득해 해당 코드를 수행할 수 있게 된다.

IDT 는 이러한 기능을 지원하는 interrupt gate 들을 저장하고 있다. 인터럽트 핸들링은 커널 모드에서 수행되기 때문에,
유저 프로그램 수행시 발생한 인터럽트 핸들링은 커널 코드 세그먼트를 요구하고, 그 `intr_gate` 들이 IDT 에 저장된다. (그 외에도 
`exception.c` 의 `exception_init()` 에서 정의한 `trap_gate` 등도 추가로 포함되어있다.)
```c
void intr_init(void) {
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init();

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
    // interrupt gate 를 만들어서 idt 에 저장한다.
    idt[i] = make_intr_gate(intr_stubs[i], 0);

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand(sizeof idt - 1, idt);
  asm volatile("lidt %0"
               :
               : "m"(idtr_operand));
  }
  
static void
register_handler(uint8_t vec_no, int dpl, enum intr_level level,
                 intr_handler_func *handler, const char *name) {
  ASSERT(intr_handlers[vec_no] == NULL);
  if (level == INTR_ON)
    // exception_init 에서 추가하는 트랩 게이트 
    idt[vec_no] = make_trap_gate(intr_stubs[vec_no], dpl);
  else
    // external device 에서 `intr_register_ext` 로 추가하는 인터럽트 게이트
    idt[vec_no] = make_intr_gate(intr_stubs[vec_no], dpl);
  intr_handlers[vec_no] = handler;
  intr_names[vec_no] = name;
}
```

이렇게 프로그램이 실행될 환경을 셋업한 이후에 `run_actions(argv)` 를 호출해 프로그램을 시작하게 된다. 
`run_actions(argv)` 의 커맨드를 확인해 보면, `action` 에 `run` 들어오게 되면, 
`run_task()` -> `process_exeecute(task)` 을 순차적으로 불러 프로세스를 실행하게 된다. 

`process_execute(task)`는 `task` 의 이름으로 스레드를 생성하고, `start_process` 를 하게 된다. 
```c
tid_t process_execute(const char *file_name) {
  // ...
  /* Create a new thread to execute FILE_NAME. */
  tid = thread_create(file_name, PRI_DEFAULT, start_process, fn_copy);
  if (tid == TID_ERROR)
    palloc_free_page(fn_copy);
  return tid;
}
```

`start_process`는 인터럽트 프레임을 설정하고, `load` 를 통해 프로그램을 메모리에 로드하고, `intr_exit` 을 이용해
마치 인터럽트에서 복귀하는 것처럼 프로그램을 실행한다. 로드에서 인자로 받는 `eip`, `esp` 는 `load` 함수에서 executable
의 엔트리 포인트를 `eip` 로 설정하고, 스택 포인터를 `esp` 로 설정한다. 

```c
bool load(const char *file_name, void (**eip)(void), void **esp) {
  
  /* load executable */
  
  // `setup_stack 은 페이지를 할당하고 esp 의 위치를 PHYS_BASE 로 설정한다.
  /*
   * 
 	
   PHYS_BASE +----------------------------------+
             |            user stack            |
             |                 |                |
             |                 |                |
             |                 V                |
             |          grows downward          |
             |                                  |
             |                                  |
             |                                  |
             |                                  |
             |           grows upward           |
             |                 ^                |
             |                 |                |
             |                 |                |
             +----------------------------------+
             | uninitialized data segment (BSS) |
             +----------------------------------+
             |     initialized data segment     |
             +----------------------------------+
             |           code segment           |
  0x08048000 +----------------------------------+
             |                                  |
             |                                  |
             |                                  |
             |                                  |
             |                                  |
           0 +----------------------------------+

   */
  if (!setup_stack(esp))
    goto done;

  /* Start address to Elf32_Ehdr's entry point */
  *eip = (void (*)(void)) ehdr.e_entry;
  
  // return true if all success
}
```



## System call procedure

## File system

TODO:

- structure(file, inode), functions(need to implement system call) of the file system in pintos
- see source codes (“filesys/ file.c”, “filesys/ inode.c” “filesys/filesys.c”) and section 3.1.2 on
  the manual

# Requirements

## 1. User Process

### A. Argument Passing

### B. Process Termination Messages

## 2. System Calls

### A. User Process Manipulation

### B. File Manipulation

## 3. Denying Writes to Executables
