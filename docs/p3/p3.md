# Project 3: Virtual Memory

## Preliminaries

Team Number: 20

윤병준(20190766)

김치헌(20190806)

# Requirements

## 1. Frame Table

### Current Implementation

#### Page and Frame

Pintos의 가상 주소 공간은 각 프로세스가 독립적으로 가지는 user memory 영역과 커널이 전역적으로 공유하는 kernel memory 영역으로 나뉜다.

user memory의 가상 주소 영역은 0부터 PHYS_BASE - 1까지이다. PHYS_BASE는 0xc0000000이다.
이 주소 영역을 4KB 단위로 나누어 관리한다. 이를 user page라고 한다.

커널 메모리의 가상 주소는 PHYS_BASE부터 시작한다. user memory와 마찬가지로 4KB 단위로 나누어 관리한다. 이를 kernel page라고 한다.
또한 커널 메모리의 가상 주소는 직접 실제 물리 주소와 매핑된다. 이는 vaddr.h의 ptov()와 vtop()를 통해 구현되어 있다.

유저 프로세스에서 가상 주소를 실제 물리 주소로 변환하는 것은 Page directory와 page table을 통해 이루어진다.

```
    31                  22 21                  12 11                   0
   +----------------------+----------------------+----------------------+
   | Page Directory Index |   Page Table Index   |    Page Offset       |
   +----------------------+----------------------+----------------------+
```

page directory의 base 주소는 thread 구조체의 `pagedir` 멤버에 저장된다.
또한 page directory가 활성화되어있다면 cr3 레지스터에 page directory의 base 주소가 저장된다.
page directory의 base 주소에 page directory index를 더한 위치에 PDE(page directory entry)가 위치한다.
PDE는 Page Table의 실제 base 주소를 가지고 있다. 이를 통해 Page Table에 접근할 수 있다.
Page Table에 접근하여 Page Table Index를 더한 위치에 PTE(page table entry)가 위치한다.
PTE를 통해 physical memory에 존재하는 page의 실제 주소를 찾을 수 있다.

#### Page Allocation and Deallocation

Pintos는 실제 메모리를 반으로 분할하여 user pools과 kernel pools로 나누어 관리한다.
user pools은 user process의 메모리를 관리하는데 사용되고, kernel pools은 kernel의 메모리를 관리하는데 사용된다.

pools은 다음과 같이 정의된다.

```c
// threads/palloc.c
/* A memory pool. */
struct pool {
  struct lock lock;        /* Mutual exclusion. */
  struct bitmap *used_map; /* Bitmap of free pages. */
  uint8_t *base;           /* Base of pool. */
};
```

`base`는 pool의 시작 주소를 가리키고, `used_map`은 pool의 사용 여부를 나타내는 bitmap이다.
used_map의 각 비트는 하나의 page를 나타내며, 1이면 사용중이고, 0이면 사용 가능한 page이다.

page를 할당받기 위해서는 palloc.c에 정의된 `palloc_get_page()` 함수를 사용한다.
palloc_get_page()는 내부적으로 `palloc_get_multiple()` 함수를 호출하는데, 이 함수가 pool에 직접 접근하여 free page를 할당받는다.
할당받는다는 것은 used_map에서 0인 비트를 찾아 1로 바꾸고, 해당 page의 주소를 반환하는 것을 의미한다.
page의 주소는 pool의 시작 주소인 `base`에 page의 index * PGSIZE를 더한 값이다.

page의 할당 해제는 마찬가지로 palloc.c에 정의된 `palloc_free_page()` 함수를 사용한다.
palloc_free_page()는 내부적으로 `palloc_free_multiple()` 함수를 호출하는데, 이 함수가 pool에 직접 접근하여 page를 해제한다.
page를 해제한다는 것은 used_map에서 1인 비트를 찾아 0으로 바꾸는 것을 의미한다.

#### Limitations

현재 pintos는 물리 주소를 두 부분으로 나누어 각각 user pools와 kernel pools로 사용하며, 각 pool이 가득 차면 page를 할당할 수 없다.
이를 해결하기 위해서는 적절한 eviction과 swap이 필요하다. eviction과 swap을 위해서는 frame table이 있어야한다.

### Solution

#### Data Structure

frame table은 physical memory의 할당된 page마다 가지는 frame table entry를 저장한다.
frame table entry는 physical memory에 할당된 page(frame)에 대한 정보를 가지며 어떤 process의 어떤 user page에 의해 사용되는지를 저장한다.

frame table과 frame table entry는 다음과 같이 정의된다.

```c
struct hash frame_table;

struct frame_table_entry {
  void *page_frame;
  struct thread *thread;
  void *upage;
  struct hash_elem elem;
};
```

frame table은 pintos에서 제공하는 hash table을 이용해 구현한다.
frame table entry는 frame table에 저장되는 데이터이다.
frame table이 hash table로 구현되기 때문에 frame table entry는 hash_elem을 멤버로 가지고 있어야 한다.
이외의 frame table entry의 멤버는 다음과 같다.
page_frame은 physical memory에 할당된 page의 주소를 가리킨다.
thread는 해당 page_frame을 사용하는 process를 가리킨다.
upage는 process의 해당 page_frame을 사용하는 user page를 가리킨다.


#### Algorithms and Implementation

- Frame Allocation

- Frame Deallocation

- Eviction

- Search frames used by user process

## 2. Lazy Loading

## 3. Supplemental Page Table

## 4. Stack Growth

## 5. File Memory Mapping

## 6. Swap Table

## 7. On Process Termination