# Project 3: Virtual Memory

## Preliminaries

Team Number: 20

윤병준(20190766)

김치헌(20190806)

# Requirements

## 1. Frame Table

### Current Implementation

#### Page and Frame

Pintos의 가상 주소 공간은 각 프로세스가 독립적으로 가지는 user memory 영역과 커널이 전역적으로 공유하는 kernel memory 영역으로 나뉜다.

user memory의 가상 주소 영역은 0부터 PHYS_BASE - 1까지이다. PHYS_BASE는 0xc0000000이다.
이 주소 영역을 4KB 단위로 나누어 관리한다. 이를 user page라고 한다.

커널 메모리의 가상 주소는 PHYS_BASE부터 시작한다. user memory와 마찬가지로 4KB 단위로 나누어 관리한다. 이를 kernel page라고 한다.
또한 커널 메모리의 가상 주소는 직접 실제 물리 주소와 매핑된다. 이는 vaddr.h의 ptov()와 vtop()를 통해 구현되어 있다.

유저 프로세스에서 가상 주소를 실제 물리 주소로 변환하는 것은 Page directory와 page table을 통해 이루어진다.

```
    31                  22 21                  12 11                   0
   +----------------------+----------------------+----------------------+
   | Page Directory Index |   Page Table Index   |    Page Offset       |
   +----------------------+----------------------+----------------------+
```

page directory의 base 주소는 thread 구조체의 `pagedir` 멤버에 저장된다.
또한 page directory가 활성화되어있다면 cr3 레지스터에 page directory의 base 주소가 저장된다.
page directory의 base 주소에 page directory index를 더한 위치에 PDE(page directory entry)가 위치한다.
PDE는 Page Table의 실제 base 주소를 가지고 있다. 이를 통해 Page Table에 접근할 수 있다.
Page Table에 접근하여 Page Table Index를 더한 위치에 PTE(page table entry)가 위치한다.
PTE를 통해 physical memory에 존재하는 page의 실제 주소를 찾을 수 있다.

#### Page Allocation and Deallocation

Pintos는 실제 메모리를 반으로 분할하여 user pools과 kernel pools로 나누어 관리한다.
user pools은 user process의 메모리를 관리하는데 사용되고, kernel pools은 kernel의 메모리를 관리하는데 사용된다.

pools은 다음과 같이 정의된다.

```c
// threads/palloc.c
/* A memory pool. */
struct pool {
  struct lock lock;        /* Mutual exclusion. */
  struct bitmap *used_map; /* Bitmap of free pages. */
  uint8_t *base;           /* Base of pool. */
};
```

`base`는 pool의 시작 주소를 가리키고, `used_map`은 pool의 사용 여부를 나타내는 bitmap이다.
used_map의 각 비트는 하나의 page를 나타내며, 1이면 사용중이고, 0이면 사용 가능한 page이다.

page를 할당받기 위해서는 palloc.c에 정의된 `palloc_get_page()` 함수를 사용한다.
palloc_get_page()는 내부적으로 `palloc_get_multiple()` 함수를 호출하는데, 이 함수가 pool에 직접 접근하여 free page를 할당받는다.
할당받는다는 것은 used_map에서 0인 비트를 찾아 1로 바꾸고, 해당 page의 주소를 반환하는 것을 의미한다.
page의 주소는 pool의 시작 주소인 `base`에 page의 index * PGSIZE를 더한 값이다.

page의 할당 해제는 마찬가지로 palloc.c에 정의된 `palloc_free_page()` 함수를 사용한다.
palloc_free_page()는 내부적으로 `palloc_free_multiple()` 함수를 호출하는데, 이 함수가 pool에 직접 접근하여 page를 해제한다.
page를 해제한다는 것은 used_map에서 1인 비트를 찾아 0으로 바꾸는 것을 의미한다.

#### Limitations

현재 pintos는 물리 주소를 두 부분으로 나누어 각각 user pools와 kernel pools로 사용하며, 각 pool이 가득 차면 page를 할당할 수 없다.
이를 해결하기 위해서는 적절한 eviction과 swap이 필요하다. eviction과 swap을 위해서는 frame table이 있어야한다.

### Solution

#### Data Structure

frame table은 physical memory의 할당된 page마다 가지는 frame table entry를 저장한다.
frame table entry는 physical memory에 할당된 page(frame)에 대한 정보를 가지며 어떤 process의 어떤 user page에 의해 사용되는지를 저장한다.

frame table과 frame table entry는 다음과 같이 정의된다.

```c
struct hash frame_table;

struct frame_table_entry {
  void *page_frame;
  struct thread *thread;
  void *upage;
  struct hash_elem elem;
};
```

frame table은 pintos에서 제공하는 hash table을 이용해 구현한다.
frame table entry는 frame table에 저장되는 데이터이다.
frame table이 hash table로 구현되기 때문에 frame table entry는 hash_elem을 멤버로 가지고 있어야 한다.
이외의 frame table entry의 멤버는 다음과 같다.
page_frame은 physical memory에 할당된 page의 주소를 가리킨다.
thread는 해당 page_frame을 사용하는 process를 가리킨다.
upage는 process의 해당 page_frame을 사용하는 user page를 가리킨다.


#### Algorithms and Implementation

- Frame Table Initialization and Hash Functions

Frame Table을 초기화하기 위해서 `frame_table_init()`를 사용한다.
`frame_table_init()`는 `hash_init()`를 호출하여 frame table을 초기화한다.

hash_init()을 위해서는 hash function과 less function이 필요하다.
hash function은 frame table entry의 frame을 hash하는 함수이다. Pintos에서 제공하는 hash_bytes()를 사용한다.
less function은 frame table entry를 비교하는 함수이다. frame table entry의 frame을 비교한 결과를 반환한다.

```c
bool frame_table_init(void) {
  return hash_init(&frame_table, frame_table_hash, frame_table_less, NULL);
}

unsigned frame_table_hash(const struct hash_elem *elem, void *aux UNUSED) {
  const struct frame_table_entry *fte = hash_entry(elem, struct frame_table_entry, elem);
  return hash_bytes(&fte->page_frame, sizeof(fte->page_frame));
}

bool frame_table_less(const struct hash_elem *a, const struct hash_elem *b, void *aux UNUSED) {
  const struct frame_table_entry *fte_a = hash_entry(a, struct frame_table_entry, elem);
  const struct frame_table_entry *fte_b = hash_entry(b, struct frame_table_entry, elem);
  return fte_a->page_frame < fte_b->page_frame;
}
```

- Frame Allocation

user page에 대한 page_frame을 할당받기 위해 frame_get_page()를 사용한다.

```c
void *frame_get_page(enum palloc_flags flags, void *upage) {
  void *page_frame = palloc_get_page(flags);
  if (page_frame == NULL) {
    frame_evict();
    page_frame = palloc_get_page(flags);
  }
  if (frame != NULL) {
    struct frame_table_entry *fte = malloc(sizeof(struct frame_table_entry));
    fte->page_frame = page_frame;
    fte->thread = thread_current();
    fte->upage = upage;
    hash_insert(&frame_table, &fte->elem);
  }
  return frame;
}
```

우선 page_frame을 할당받는다. 이때 palloc_get_page()를 사용한다. flags에 따라 어떤 pool에서 할당받을지 결정된다.
만약 할당받을 수 없다면 frame_evict()를 호출한 후에 다시 page_frame을 할당받는다. frame_evict()는 아래에서 설명한다.
page_frame을 할당받았다면 frame table entry를 생성하여 각 멤버를 초기화한 후 frame table에 추가한다.
이후, 할당받은 page_frame의 주소를 반환한다.

- Frame Deallocation

page_frame을 해제하기 위해 frame_free_page()를 사용한다.

```c
void frame_free_page(void *page_frame) {
  struct frame_table_entry fte;
  fte.page_frame = page_frame;
  struct hash_elem *e = hash_find(&frame_table, &fte.elem);
  if (e != NULL) {
    hash_delete(&frame_table, e);
    palloc_free_page(page_frame);
    free(hash_entry(e, struct frame_table_entry, elem));
  }
}
```

user page의 frame을 해제하기 위해서는 frame table에서 해당 frame을 가지는 frame table entry를 찾아야 한다.
이를 위해 frame table entry를 생성하고, frame을 설정하여 이를 frame table에서 찾는다.
만약 찾았다면 frame table에서 해당 frame을 가지는 frame table entry를 삭제하고, frame table entry를 해제한다.

- Eviction

Eviction policy는 page_frame을 더 이상 할당 받을 수 없을 때 이미 할당된 page_frame 중에서 할당을 해제할 page_frame을 결정하는 정책이다.
Eviction policy는 page replacement algorithm의 중요한 구성 요소이다.

Eviction policy를 결정하는데 사용할 수 있는 정보는 PTE에 저장된 accessed bit이다.
accessed bit는 해당 page가 최근에 접근되었는지를 나타내는 bit로, 해당 page에 대한 read나 write가 발생할 때 설정된다.
accessed bit를 이용하여 approximated LRU(Least Recently Used)를 eviction policy로 사용한다.
구현은 다음과 같다.

```c
void frame_evict(void) {
  struct frame_table_entry *target = NULL;
  struct hash_iterator i;
  hash_first(&i, &frame_table);
  while (hash_next(&i)) {
    struct frame_table_entry *fte = hash_entry(hash_cur(&i), struct frame_table_entry, elem);
    if (target != NULL)
      pagedir_set_accessed(target->thread->pagedir, target->upage, false);
    if (!pagedir_is_accessed(fte->thread->pagedir, fte->upage)) {
      target = fte;
    }
    pagedir_set_accessed(fte->thread->pagedir, target->upage, false);
  }
  if (target == NULL) {
    hash_first(&i, &frame_table);
    target = hash_entry(hash_cur(&i), struct frame_table_entry, elem);
    // if target dirty, write to swap
  }
  
  hash_delete(&frame_table, &target->elem);
  pagedir_clear_page(target->thread->pagedir, target->upage);
  palloc_free_page(target->page_frame);
  free(target);
}
```

frame_table을 순회하면서 accessed bit가 설정되어 있지 않은 page를 가진 frame table entry를 찾는다.
만약 찾았다면 해당 frame table entry를 target으로 한다.
target을 제외한 나머지에 대해서는 accessed bit를 false로 초기화한다.
이는 다음 frame_evict()가 호출될 때, 현재 frame_evict() 이후로 해당 page에 read나 write가 발생하였는지 확인하기 위함이다.
찾을 수 없다면 target은 hash_first()를 통해 frame_table의 첫 번째 frame table entry로 설정한다.
이 경우 target에 지정된 page는 dirty bit를 가지고 있을 수 있다.
이는 target에 write된 내용이 있다는 뜻으로, 이 경우 target을 swap_disk에 저장한다.
swap에 대한 자세한 내용은 아래 6. Swap Table에서 설명한다.

이후, target에 대한 eviction을 진행한다.
eviction은 frame table에서 target을 삭제하고, target을 사용하는 process의 page directory에서 해당 page를 지운다.
palloc_get_page()로 할당받았던 page_frame을 해제하고 마지막으로 frame table entry인 target을 해제한다.

- Search frames used by user process

특정 user process에서 사용 중인 frame을 찾기 위해서는 먼저 frame_table을 순회하면서 thread가 일치하는 frame table entry를 찾는다.
이후 해당 frame table entry의 frame 주소가 user pools에서 할당받은 frame인지 확인하여 찾아낼 수 있다.

## 2. Lazy Loading

### Current Implementation

#### Loading Executable

현재 pintos는 user process를 실행하기 위해 필요한 모든 내용을 executable file에서 읽어와 메모리에 적재한다.
실행에 필요한 모든 정보가 page로 올라와 있기 때문에 이후 user process를 실행하는 동안 발생하는 page fault는 에러 상황으로 처리된다.

```c

```

#### Limitations

현재 구현에서는 user process를 loading할 때, 모든 내용을 한 번에 읽어오기 때문에 비효율적이다.
또한, 이 과정에서 할당할 수 있는 page가 부족하다면 load가 실패하기 때문에 user process를 아예 실행할 수 없다.
page 부족은 eviction을 통해 해결할 수 있지만, 여전히 실행하는데 당장 필요하지 않은 모든 page가 메모리에 적재되어 있기 때문에 비효율적이다.
이를 해결하기 위해서 동적으로 loading이 필요할 때 loading을 진행하는 lazy loading이 필요하다.

### Solution

#### Data Structure

#### Algorithms and Implementation

## 3. Supplemental Page Table

### Current Implementation

#### ...

#### Limitations

### Solution

#### Data Structure

#### Algorithms and Implementation

## 4. Stack Growth

### Current Implementation

#### ...

#### Limitations

### Solution

#### Data Structure

#### Algorithms and Implementation

## 5. File Memory Mapping

### Current Implementation

#### ...

#### Limitations

### Solution

#### Data Structure

#### Algorithms and Implementation

## 6. Swap Table

### Current Implementation

#### ...

#### Limitations

### Solution

#### Data Structure

#### Algorithms and Implementation

## 7. On Process Termination

### Current Implementation

#### ...

#### Limitations

### Solution

#### Data Structure

#### Algorithms and Implementation
