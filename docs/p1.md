# Project 1: Threads

## Preliminaries

Team Number: 20

윤병준(20190766)

김치헌(20190807)

## Table of Contents
- [Project 1: Threads](#project-1--threads)
  * [Preliminaries](#preliminaries)
- [Analysis of the current implementation](#analysis-of-the-current-implementation)
  * [Threads](#threads)
    + [Overview of Thread life cycle implementation in PintOS](#overview-of-thread-life-cycle-implementation-in-pintos)
    + [Thread State](#thread-state)
  * [Thread Switching](#thread-switching)
    + [`schedule()`](#-schedule---)
    + [`switch_threads()`](#-switch-threads---)
    + [Special Case: Starting a Thread for the First Time](#special-case--starting-a-thread-for-the-first-time)
  * [Syncronization Primitives](#syncronization-primitives)
    + [Lock](#lock)
    + [Semaphore](#semaphore)
    + [Condition Variable](#condition-variable)
    + [Optimization barrier](#optimization-barrier)
- [Requirements](#requirements)
  * [Alarm Clock](#alarm-clock)
    + [Overall structure](#overall-structure)
    + [Data Structures](#data-structures)
    + [Algorithms](#algorithms)
    + [Implementation](#implementation)
    + [Rationale](#rationale)
  * [Priority Scheduling](#priority-scheduling)
    + [Overall structure](#overall-structure-1)
    + [Data Structures](#data-structures-1)
    + [Algorithms](#algorithms-1)
    + [Implementation](#implementation-1)
    + [Rationale](#rationale-1)
  * [Advanced Scheduler](#advanced-scheduler)
    + [Overall structure](#overall-structure-2)
    + [Data Structures](#data-structures-2)
    + [Algorithms](#algorithms-2)
    + [Implementation](#implementation-2)
    + [Rationale](#rationale-2)

# Analysis of the current implementation

## Threads

### Overview of Thread life cycle implementation in PintOS

The current implementation of threads in PintOS starts at `main()` in `src/threads/init.c`.

```c
int main(void) {
  /* initialization */
  thread_init();
  /* Init memory system */
  thread_start();
  /* shutdown */
  thread_exit();
}
```

`thread_init()`'s primary purpose is to create the first thread for PintOS. A key feature of `thread_init()` is to set
the MAGIC value to the running thread. Details of the MAGIC value are explained at the top of `thread.h`. The MAGIC
value is used to check whether the thread is valid or not. Since `struct thread` should not grow too large, its magic
member will work as a validity checker.

`thread_start` will create an `idle` thread (with `thread_create`) and use `sema_down` to prevent other processes from
joining. Once the `idle thread` is created, it will `sema_up` to release the last `sema_down` from `thread_create`.
Then, it blocks itself, allowing the `run_action` in `main()` to run another thread. The idle thread will wake up when
there are no available threads to run.

`thread_create` will create a new thread based on the given argument. The function receives a function name, priority,
and an argument (`aux`). This function will allocate memory for a page for `struct thread` and stack frames
for `kernel_thread` and switching. Initially, `init_thread` initializes a thread in the `THREAD_BLOCKED` state. Just
before returning, `thread_unblock()` is called, setting the thread state to `THREAD_READY`.

### Thread Memory Layout
<p align="center">
  <img src="img/p1_1_thread_memory_layout.png" alt="thread_memory_layout"  />
</p>

### Thread State

<!-- 
digraph finite_state_machine {
    rankdir=TB;

    node [shape = rectangle];
    center [shape=none, width=0, height=0, label=""];  // Invisible center node

    // Triangle arrangement
    center -> THREAD_READY [style=invis];


    // Initialization state
    init [shape=point];   // This represents the small dot or circle
    init -> THREAD_READY;

    {rank=min; init THREAD_READY THREAD_RUNNING THREAD_DYING exit}
    
    init -> exit [style=invis]
    exit [shape=point];
    
    THREAD_READY -> THREAD_RUNNING [label="schedule()", minlen=4]
    THREAD_RUNNING -> THREAD_READY [label="thread_yield()"]
    THREAD_RUNNING -> THREAD_DYING [label="thread_exit()"]
    THREAD_RUNNING -> THREAD_BLOCKED [label="thread_block()"]
    THREAD_BLOCKED -> THREAD_READY [taillabel="thread_unblock()\n\n"]

    THREAD_DYING -> exit
}
-->
<p align="center">
  <img src="img/p1_1_thread_state.svg" alt="thread_state"  />
</p>

The state diagram of the thread life cycle has one exception: the `THREAD_RUNNING` state can be initialized
by `thread_init()`, called by `main()` to set the first thread.

- `THREAD_READY`: The thread is ready to run but isn't running. Once the scheduler selects this thread, it will run
  next. Managed in `ready_list` in `src/threads/thread.c`.

- `THREAD_RUNNING`: The thread is currently running, and only one thread can be in this state.

- `THREAD_BLOCKED`: The thread is blocked, waiting for an event such as a lock release or a semaphore to be upped.

- `THREAD_DYING`: The thread will be destroyed soon.

This life cycle is defined in `src/threads/thread.c` as the enum `thread_status`. This enum is stored in the `status`
member of `struct thread`.

```c
/* States in a thread's life cycle. */
enum thread_status {
  THREAD_RUNNING,     /* Running thread. */
  THREAD_READY,       /* Not running but ready to run. */
  THREAD_BLOCKED,     /* Waiting for an event to trigger. */
  THREAD_DYING        /* About to be destroyed. */
};
```

A key aspect of the thread life cycle is determining the order in which threads run next or how the OS manages the
priority of threads in the `ready_list`. The current implementation of `ready_list` is as a FIFO list containing all
threads ready to run.

## Thread Switching
### Overview
<p align="center">
  <img src="img/p1_3_thread_switch.drawio.png" alt="thread_switching"  />
</p>

### `schedule()`

`schedule()` is responsible for deciding which thread runs next. This function is invoked
by: `thread_block()`, `thread_exit()`, and `thread_yield()`. Before calling `schedule()`, interrupts should be disabled
by using `intr_disable()`. If interrupts are not disabled, an interrupt handler might be called during thread
switching. `schedule()` chooses the next thread by invoking `next_thread_to_run()` and switches from the current to the
next thread.

`thread_schedule_tail()` completes the switching process. It sets the current thread to the `THREAD_RUNNING` state and
starts a new time slice. If the thread being switched from is in the `THREAD_DYING` state, we free the allocated memory,
which includes `struct thread` and the `stack frame`. We free the memory after switching because we need the information
in this memory for `switch_threads()`. Freeing the memory before switching would prevent access to this necessary
information.

### `switch_threads()`

Within `switchs.S`, we find the assembly code responsible for thread switching. The `CUR` thread is the one currently
executing, while the `NEXT` thread is the one we'll be switching to. The purpose of `switch_threads()` is to save the
state of `CUR` and restore the state of `NEXT`. Let's break down the process:

1. **Save Registers**

```asm
pushl %ebx
pushl %ebp
pushl %esi
pushl %edi
```

The registers `ebx`, `ebp`, `esi`, and `edi` are callee-saved registers. It's imperative that a called function
preserves their values.

2. **Save Current Stack Pointer**

```asm
mov thread_stack_ofs, %edx # uint32_t thread_stack_ofs = offsetof(struct thread, stack); from thread.c
movl SWITCH_CUR(%esp), %eax
movl %esp, (%eax,%edx,1)
```

The `thread_stack_ofs` represents the offset of the `stack` member in the `struct thread`. `SWITCH_CUR` is the offset
from the `struct switch_threads_frame` to the `cur` member. The operation `movl SWITCH_CUR(%esp), %eax` yields a pointer
to the current thread's `struct thread`. The last line here saves the current stack pointer to the `stack` member of the
current thread.

3. **Restore Next Stack Pointer**

```asm
movl SWITCH_NEXT(%esp), %eax
movl (%eax,%edx,1), %esp
```

Similarly, `movl SWITCH_NEXT(%esp), %eax` results in a pointer to the next thread's `struct thread`.
Adding `thread_stack_ofs`, now stored in `%edx`, yields a pointer to the `stack` member of the next thread. The final
line restores the stack pointer of the next thread.

4. **Restore Registers**

```asm
popl %edi
popl %esi
popl %ebp
popl %ebx
```

5. **Return to Caller**

```asm
ret
```

### Special Case: Starting a Thread for the First Time

The initialization of a thread poses a unique challenge. Specifically, the stack pointer for the thread hasn't been set
yet. As noted, `switch_threads()` requires information about the previous stack to switch to the next thread correctly.
However, an initial thread lacks this prior stack. Thus, it becomes necessary to initialize certain stack frames for the
first thread. This initialization is performed in `thread_start()`, found in `src/threads/thread.c`.

```c
tid_t
thread_create(const char *name, int priority,
              thread_func *function, void *aux)
{
  struct thread *t;
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
```

At the top is the `switch_threads_frame`. Its `eip` points to `switch_entry()`, as defined in `switch.S`. This means
that the next function to be called will be `switch_entry()`.

The subsequent frame is `switch_entry_frame`, whose task is to invoke `thread_schedule_tail()` for the first time. A
more detailed description follows:

```asm
# Implementation of switch_entry() in `switch.S`
addl $8, %esp # discard switch_threads() arguments: cur and next
pushl %eax    # push SWITCH_CUR(%esp) to the stack, which will be the argument for thread_schedule_tail()
              # SWITCH_CUR(%esp) points to the current thread's struct thread
call thread_schedule_tail 
addl $4, %esp # clean up stack
```

The `switch_entry` function aids `switch_threads()`. Its main job is to discard the arguments to `switch_threads()` and
then call `thread_schedule_tail()`.

Lastly, we have `kernel_thread_frame`, which calls `function` with `aux` as its argument. Within `kernel_thread()`,
interrupts are enabled, `function` is called with the argument `aux`, and finally, `thread_exit()` is invoked.

In summary, the roles of `kernel_thread_frame`, `switch_entry_frame`, and `switch_threads_frame` are to establish the
correct execution environment for the first thread. This setup ensures that the initial thread can seamlessly
invoke `thread_schedule_tail()` and switch to the next thread.

## Syncronization Primitives

### Lock

### Semaphore

### Condition Variable

### Optimization barrier

# Requirements

## Alarm Clock

### Overall structure

### Data Structures

### Algorithms

### Implementation

### Rationale

## Priority Scheduling

### Overall structure

### Data Structures

### Algorithms

### Implementation

### Rationale

## Advanced Scheduler

### Overall structure

### Data Structures

### Algorithms

### Implementation

### Rationale