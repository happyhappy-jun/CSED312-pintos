# Project 1: Threads

## Preliminaries

Team Number: 20

윤병준(20190766)

김치헌(20190807)

*We use GPT-4 to revise grammar errors in this report.*

## Table of Contents

- [Project 1: Threads](#project-1--threads)
    * [Preliminaries](#preliminaries)
- [Analysis of the current implementation](#analysis-of-the-current-implementation)
    * [Threads](#threads)
        + [Overview of Thread life cycle implementation in PintOS](#overview-of-thread-life-cycle-implementation-in-pintos)
        + [Thread State](#thread-state)
    * [Thread Switching](#thread-switching)
        + [`schedule()`](#-schedule---)
        + [`switch_threads()`](#-switch-threads---)
        + [Special Case: Starting a Thread for the First Time](#special-case--starting-a-thread-for-the-first-time)
    * [Syncronization Primitives](#syncronization-primitives)
        + [Lock](#lock)
        + [Semaphore](#semaphore)
        + [Condition Variable](#condition-variable)
        + [Optimization barrier](#optimization-barrier)
- [Requirements](#requirements)
    * [Alarm Clock](#alarm-clock)
        + [Overall structure](#overall-structure)
        + [Data Structures](#data-structures)
        + [Algorithms](#algorithms)
        + [Implementation](#implementation)
        + [Rationale](#rationale)
    * [Priority Scheduling](#priority-scheduling)
        + [Overall structure](#overall-structure-1)
        + [Data Structures](#data-structures-1)
        + [Algorithms](#algorithms-1)
        + [Implementation](#implementation-1)
        + [Rationale](#rationale-1)
    * [Advanced Scheduler](#advanced-scheduler)
        + [Overall structure](#overall-structure-2)
        + [Data Structures](#data-structures-2)
        + [Algorithms](#algorithms-2)
        + [Implementation](#implementation-2)
        + [Rationale](#rationale-2)

# Analysis of the current implementation

## Threads

### Overview of Thread life cycle implementation in PintOS

The current implementation of threads in PintOS starts at `main()` in `src/threads/init.c`.

```c
int main(void) {
  /* initialization */
  thread_init();
  /* Init memory system */
  thread_start();
  /* shutdown */
  thread_exit();
}
```

`thread_init()`'s primary purpose is to create the first thread for PintOS. A key feature of `thread_init()` is to set
the MAGIC value to the running thread. Details of the MAGIC value are explained at the top of `thread.h`. The MAGIC
value is used to check whether the thread is valid or not. Since `struct thread` should not grow too large, its magic
member will work as a validity checker.

`thread_start` will create an `idle` thread (with `thread_create`) and use `sema_down` to prevent other processes from
joining. Once the `idle thread` is created, it will `sema_up` to release the last `sema_down` from `thread_create`.
Then, it blocks itself, allowing the `run_action` in `main()` to run another thread. The idle thread will wake up when
there are no available threads to run.

`thread_create` will create a new thread based on the given argument. The function receives a function name, priority,
and an argument (`aux`). This function will allocate memory for a page for `struct thread` and stack frames
for `kernel_thread` and switching. Initially, `init_thread` initializes a thread in the `THREAD_BLOCKED` state. Just
before returning, `thread_unblock()` is called, setting the thread state to `THREAD_READY`.

### Thread Memory Layout

Suppose `thread_create()` is called with argument `"alarm_single"`. Then, the memory layout of the thread will be as
follows:

<p align="center">
  <img src="img/p1_1_thread_memory_layout.png" alt="thread_memory_layout"  />
</p>

`struct thread` locate at the very bottom of the page, the stack frame for `kernel_thread` is located on the top of the
page, and stack frame of called functions grow downward. If stack frame grows too large, it will overlap with
the `struct
thread`. Resulting in a memory corruption, which can be identified by checking the MAGIC value.

### Thread State

<!-- 
digraph finite_state_machine {
    rankdir=TB;

    node [shape = rectangle];
    center [shape=none, width=0, height=0, label=""];  // Invisible center node

    // Triangle arrangement
    center -> THREAD_READY [style=invis];


    // Initialization state
    init [shape=point];   // This represents the small dot or circle
    init -> THREAD_READY;

    {rank=min; init THREAD_READY THREAD_RUNNING THREAD_DYING exit}
    
    init -> exit [style=invis]
    exit [shape=point];
    
    THREAD_READY -> THREAD_RUNNING [label="schedule()", minlen=4]
    THREAD_RUNNING -> THREAD_READY [label="thread_yield()"]
    THREAD_RUNNING -> THREAD_DYING [label="thread_exit()"]
    THREAD_RUNNING -> THREAD_BLOCKED [label="thread_block()"]
    THREAD_BLOCKED -> THREAD_READY [taillabel="thread_unblock()\n\n"]

    THREAD_DYING -> exit
}
-->
<p align="center">
  <img src="img/p1_1_thread_state.svg" alt="thread_state"  />
</p>

The state diagram of the thread life cycle has one exception: the `THREAD_RUNNING` state can be initialized
by `thread_init()`, called by `main()` to set the first thread.

- `THREAD_READY`: The thread is ready to run but isn't running. Once the scheduler selects this thread, it will run
  next. Managed in `ready_list` in `src/threads/thread.c`.

- `THREAD_RUNNING`: The thread is currently running, and only one thread can be in this state.

- `THREAD_BLOCKED`: The thread is blocked, waiting for an event such as a lock release or a semaphore to be upped.

- `THREAD_DYING`: The thread will be destroyed soon.

This life cycle is defined in `src/threads/thread.c` as the enum `thread_status`. This enum is stored in the `status`
member of `struct thread`.

```c
/* States in a thread's life cycle. */
enum thread_status {
  THREAD_RUNNING,     /* Running thread. */
  THREAD_READY,       /* Not running but ready to run. */
  THREAD_BLOCKED,     /* Waiting for an event to trigger. */
  THREAD_DYING        /* About to be destroyed. */
};
```

A key aspect of the thread life cycle is determining the order in which threads run next or how the OS manages the
priority of threads in the `ready_list`. The current implementation of `ready_list` is as a FIFO list containing all
threads ready to run.

## Thread Switching

### Overview

<p align="center">
  <img src="img/p1_3_thread_switch.drawio.png" alt="thread_switching"  />
</p>

The above diagram shows the process of thread switching. The current thread is in the `THREAD_RUNNING` state. If a
thread
has used up its timeslice, `thread_tick()` (called by `timer_interrupt`) will call the
function `intr_yield_on_return()`. `intr_yield_on_return()` change `yield_on_return` flag to `true` and let 
`intr_handler` know. Then, `intr_handler` will call `thread_yield()` to switch to the next thread. `thread_yield()` will
call `schedule()` and `switch_threads()` to switch to the next thread during interrupt.

### `schedule()`

`schedule()` is responsible for deciding which thread runs next. This function is invoked
by: `thread_block()`, `thread_exit()`, and `thread_yield()`. Before calling `schedule()`, interrupts should be disabled
by using `intr_disable()`. If interrupts are not disabled, an interrupt handler might be called during thread
switching. `schedule()` chooses the next thread by invoking `next_thread_to_run()` and switches from the current to the
next thread.

`thread_schedule_tail()` completes the switching process. It sets the current thread to the `THREAD_RUNNING` state and
starts a new time slice. If the thread being switched from is in the `THREAD_DYING` state, we free the allocated memory,
which includes `struct thread` and the `stack frame`. We free the memory after switching because we need the information
in this memory for `switch_threads()`. Freeing the memory before switching would prevent access to this necessary
information.

### `switch_threads()`

Within `switchs.S`, we find the assembly code responsible for thread switching. The `CUR` thread is the one currently
executing, while the `NEXT` thread is the one we'll be switching to. The purpose of `switch_threads()` is to save the
state of `CUR` and restore the state of `NEXT`. Let's break down the process:

1. **Save Registers**

```asm
pushl %ebx
pushl %ebp
pushl %esi
pushl %edi
```

The registers `ebx`, `ebp`, `esi`, and `edi` are callee-saved registers. It's imperative that a called function
preserves their values.

2. **Save Current Stack Pointer**

```asm
mov thread_stack_ofs, %edx # uint32_t thread_stack_ofs = offsetof(struct thread, stack); from thread.c
movl SWITCH_CUR(%esp), %eax
movl %esp, (%eax,%edx,1)
```

The `thread_stack_ofs` represents the offset of the `stack` member in the `struct thread`. `SWITCH_CUR` is the offset
from the `struct switch_threads_frame` to the `cur` member. The operation `movl SWITCH_CUR(%esp), %eax` yields a pointer
to the current thread's `struct thread`. The last line here saves the current stack pointer to the `stack` member of the
current thread.

3. **Restore Next Stack Pointer**

```asm
movl SWITCH_NEXT(%esp), %eax
movl (%eax,%edx,1), %esp
```

Similarly, `movl SWITCH_NEXT(%esp), %eax` results in a pointer to the next thread's `struct thread`.
Adding `thread_stack_ofs`, now stored in `%edx`, yields a pointer to the `stack` member of the next thread. The final
line restores the stack pointer of the next thread.

4. **Restore Registers**

```asm
popl %edi
popl %esi
popl %ebp
popl %ebx
```

5. **Return to Caller**

```asm
ret
```

### Special Case: Starting a Thread for the First Time

The initialization of a thread poses a unique challenge. Specifically, the stack pointer for the thread hasn't been set
yet. As noted, `switch_threads()` requires information about the previous stack to switch to the next thread correctly.
However, an initial thread lacks this prior stack. Thus, it becomes necessary to initialize certain stack frames for the
first thread. This initialization is performed in `thread_start()`, found in `src/threads/thread.c`.

```c
tid_t
thread_create(const char *name, int priority,
              thread_func *function, void *aux)
{
  struct thread *t;
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
```

At the top is the `switch_threads_frame`. Its `eip` points to `switch_entry()`, as defined in `switch.S`. This means
that the next function to be called will be `switch_entry()`.

The subsequent frame is `switch_entry_frame`, whose task is to invoke `thread_schedule_tail()` for the first time. A
more detailed description follows:

```asm
# Implementation of switch_entry() in `switch.S`
addl $8, %esp # discard switch_threads() arguments: cur and next
pushl %eax    # push SWITCH_CUR(%esp) to the stack, which will be the argument for thread_schedule_tail()
              # SWITCH_CUR(%esp) points to the current thread's struct thread
call thread_schedule_tail 
addl $4, %esp # clean up stack
```

The `switch_entry` function aids `switch_threads()`. Its main job is to discard the arguments to `switch_threads()` and
then call `thread_schedule_tail()`.

Lastly, we have `kernel_thread_frame`, which calls `function` with `aux` as its argument. Within `kernel_thread()`,
interrupts are enabled, `function` is called with the argument `aux`, and finally, `thread_exit()` is invoked.

In summary, the roles of `kernel_thread_frame`, `switch_entry_frame`, and `switch_threads_frame` are to establish the
correct execution environment for the first thread. This setup ensures that the initial thread can seamlessly
invoke `thread_schedule_tail()` and switch to the next thread.

## Syncronization Primitives

### Semaphore
A semaphore is a type of synchronization that is invented to control access to a common resource shared by multiple threads.

The semaphore S is a variable that holds a integer value, and this value can be accessed and edited by only two operators denoted P and V.

The integer value holds by the semaphore is the number of the units that are currently available.

P is called before a thread is trying to access the critical section(common resource that should not be accessed by two or more threads).
If the semaphore value is over 1, decrement the value and enter the critical section.
If not, the thread waits until the value be positive, then enter the critical section, decrementing the value.

V is called after a thread complete the operation in the critical section.
V simply increments the semaphore value.

In pintos, `semaphore` is implemented as a structure.
```c++
struct semaphore
  {
    unsigned value;         /* Current value. */
    struct list waiters;    /* List of waiting threads */
  };
```
A `semaphore` is initiated by `sema_init()`. For P and V, `sema_up()` and `sema_down()` is implemented.

- `sema_init()`: Set an initial value for the variable `value` and initiate a list `waiters`.
- `sema_down()`: P. If `value` is 0, the caller thread is pushed into the `waiters` by `list_push_back()` and blocked by `thread_block()`.
  when the `value` became positive, the caller thread decrement the `value` and return to access the critical section.
- `sema_up()` : V. If `waiters` is not empty (i.e. there are threads that want to access the critical section), the front thread is popped by `list_pop_front()`.
  Then the popped thread take access to critical section. Regardless of `waiters`, `sema_ip()` increments the `value`.

In genenral, according to the definition of the semaphore, the value of the semaphore should be initialized to a positive number depending on the number of resources available.
However, we can find that pintos initialize the value with zero and then call `sema_down()`.
In this case, the caller (i.e. the thread which initialized the semaphore and called `sema_down()`) immediately pushed into `waiters` and then blocked.
As the caller whose state was running is blocked, another thread in the ready list is selected and become the next running thread.
The selected running thread do its work and then call `sema_up()` to make the previous running thread become the current running thread again.
A typical example is the initializing step of the `idle` thread. The `main` thread initialize the semaphore `idle_started` with `value` 0 and call `sema_down` to pass the control flow to `idle` thread.
After the function `idle()` is started, `idle` thread call `sema_up()` to give the control flow back to the `main` thread.

There are other functions for `semaphore` in pintos, `sema_try_down()` and `sema_self_test()`.

`sema_try_down()` is similar to `sema_down()` as it is a kind of P function. But it works only when the `value` is positive.
In other words, if the `value` is 0, it returns `false` and the caller neither enter the `waiters` nor becomes blocked.
If the `value` is positive, it decreases the `value` by 1 and return `true`.

`sema_self_test()` is a function for self testing.

### Lock
A Lock is a synchronization primitives. It is used for controlling access to a common resource like semaphore.
The semaphore's P(or "down") is "acquire" in the lock and the V (or "up") of the semaphore is "release" in the lock.

There are two main difference between a lock and a semaphore.

- One is the range of the value can have.
A Semaphore can have various values bigger than 1, but the value of a lock only can be 0 or 1.
In other words, a lock is a kind of binary semaphores.

- Another is the presence of the lock holder.
In semaphore, there is no owner or holder. It means a thread can "up" the semaphore without being the thread "downed" it.
In contrast, a lock can only be "released" by the thread that "acquired" it.

In pintos, a lock is implemented by a structure.
```c++
struct lock
  {
    struct thread *holder;          /* Thread holding lock */
    struct semaphore semaphore;     /* Binary semaphore controlling access */
  };
```
As a lock perform like a binary semaphore, it has a `semaphore` as member variable, and `holder` for the thread holding the lock.

A lock is initialized by `lock_init()`. There are 4 functions to implement the lock features.

- `lock_init()`: Initialize `holder` and `semaphore`. There is no holder at the beginning so initialize `holder` with `NULL`.
And as the lock is the binary semaphore, `semaphore` is initialized with the value 1.
- `lock_acquire()`: Checks whether the `holder` is the caller(it must not), and then invoke `sema_down()`. Then set the `holder` the current thread.
- `lock_release()`: Checks whether the `holder` is the caller(it must be), and then set the `holder` NULL. Then invoke `sema_up()`.
- `lock_try_acquire()`: Lock version of `sema_try_down()`. Acquire the lock only when the lock is acquired by another thread.
- `lock_held_by_current_thread()`: `lock_acquire()` and `lock_release()` use this function to check the `holder`.
It returns `true` if the `holder` is the current thread. Otherwise, it returns `false`. 


### Condition Variable

### Optimization barrier

# Requirements

## Alarm Clock

### Overall structure

### Data Structures

### Algorithms

### Implementation

### Rationale

## Priority Scheduling

### Overall structure

### Data Structures

### Algorithms

### Implementation

### Rationale

## Advanced Scheduler

### Overall structure

### Data Structures

### Algorithms

### Implementation

### Rationale